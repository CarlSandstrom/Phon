__copyright__ = "Copyright (C) 2013 Kristoffer Carlsson"

__license__ = """
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

"""
Module that contains the method of reading a mesh from a series of .msh files
generated by gmsh.
"""

import re

from phon.mesh_objects.element import Element
from phon.mesh_objects.node import Node
from phon.mesh_objects.mesh import Mesh

from phon.mesh_objects.element_set import ElementSet
from phon.mesh_objects.element_side_set import ElementSideSet
from phon.mesh_objects.element_side_set import ElementSide
from phon.mesh_objects.node_set import NodeSet

import numpy.linalg


def read_from_gmsh_inp(basename, ngrains, verbose=0):
    """
    Reads a sequence of grains from *.msh-files generated by GMsh (and Dream3D) and stores it into a 
    Mesh class object.
    
    :param basename: The base name of the files sequence from where to read the mesh from.
    :type basename: string
    :param verbose: Determines what level of print out to the console.
    :type verbose: 0, 1 or 2
    :return: A mesh class containing the read mesh objects.
    :rtype: :class:`Mesh`
    :raises ReadInpFileError: If specific syntax error are found.
    """
    elem2grain = dict()
    mesh = Mesh("grains")
    for grainid in range(1, ngrains+1):
        filename = basename + str(grainid) + ".msh"
        print("Reading grain " + str(grainid))
        grainmesh = Mesh("grain" + str(grainid))
        with open(filename, "rU") as f:
            # Read mesh objects
            num_elems = 0
            while True:
                keyword = f.readline().strip()
                if keyword == "$Nodes":
                    print("Reading nodes")
                    _read_nodes(f, grainmesh)
                elif keyword == "$Elements":
                    print("Reading elements")
                    _read_elements(f, grainmesh)
                    break

        f.close()
        print("Merging grain")
        _merge_mesh(mesh, elem2grain, grainmesh, grainid)
    # Need to create some additional sets for bcs.
    _create_bc_sets(mesh)
    return mesh


def _create_bc_sets(mesh):
    min_coord = [0., 0., 0.]
    max_coord = [0., 0., 0.]
    for node in mesh.nodes.values():
        max_coord[0] = max(max_coord[0], node.x)
        max_coord[1] = max(max_coord[1], node.y)
        max_coord[2] = max(max_coord[2], node.z)
        min_coord[0] = min(min_coord[0], node.x)
        min_coord[1] = min(min_coord[1], node.y)
        min_coord[2] = min(min_coord[2], node.z)

    mesh.node_sets["z0"] = NodeSet("z0")
    mesh.node_sets["z1"] = NodeSet("z1")
    for n_id, node in mesh.nodes.items():
        if node.z <= min_coord[2] + 1e-6:
            mesh.node_sets["z0"].ids.append(n_id)
        elif node.z >= max_coord[2] - 1e-6:
            mesh.node_sets["z1"].ids.append(n_id)

    mesh.element_side_sets["surface"] = ElementSideSet("surface")
    surf_ids = [[0, 2, 1], [0, 1, 3], [1, 2, 3], [0, 3, 2]]
    for e_id, elem in mesh.elements.items():
        v = elem.vertices
        if len(v) < 4:
            continue
        for s_id, s in enumerate(surf_ids):
            ns = [mesh.nodes[v[x]] for x in s]
            ax = all([n.x <= min_coord[0] + 1e-6 for n in ns])
            ay = all([n.y <= min_coord[1] + 1e-6 for n in ns])
            az = all([n.z <= min_coord[2] + 1e-6 for n in ns])
            bx = all([n.x >= max_coord[0] - 1e-6 for n in ns])
            by = all([n.y >= max_coord[1] - 1e-6 for n in ns])
            bz = all([n.z >= max_coord[2] - 1e-6 for n in ns])
            if any([ax, ay, az, bx, by, bz]):
                mesh.element_side_sets["surface"].sides.append(ElementSide(e_id, s_id+1))


def _construct_node2element(mesh):
    node2elements = [list() for n in range(0,len(mesh.nodes)+11)]
    for element_id, element in mesh.elements.items():
        if len(element.vertices) < 4:
            continue
        for n in element.vertices:
            node2elements[n].append(element_id)
    return node2elements


def _merge_mesh(mesh, elem2grain, grainmesh, grainid):
    # Create element sets for all potential faces:
    for i in range(1, grainid):
        mesh.element_sets["face"+ str(i) + "_" + str(grainid)] = ElementSet("face"+ str(i) + "_" + str(grainid), 2)

    node2node, node_merge_list = _find_duplicate_nodes(mesh, grainmesh)

    node2elements2 = _construct_node2element(mesh)
    # Need these to append new nodes and elements:
    elemcount = 0
    if len(mesh.elements) > 0:
        elemcount = max(mesh.elements.keys())

    surf_ids = [[0, 2, 1], [0, 1, 3], [1, 2, 3], [0, 3, 2]]
    # Find only elements in grainmesh that should have a matching surface;
    for e1, elem1 in grainmesh.elements.items():
        v1 = elem1.vertices  # Nodes numbers in "grainmesh"
        v2 = [node2node[v] for v in v1]  # Node numbers in "mesh"

        # Check for surfaces, and if so, add them to a set
        # Right now, I just add triangular elements.
        for s in surf_ids:
            if all([v1[x] in node_merge_list for x in s]):
                e2 = set.intersection(*[set(node2elements2[v2[x]]) for x in s])
                if len(e2) > 0:
                    surfelem = Element("CPE3", [v2[x] for x in s])
                    elemcount += 1
                    mesh.elements[elemcount] = surfelem
                    id2 = elem2grain[e2.pop()]
                    mesh.element_sets["face"+ str(id2) + "_" + str(grainid)].ids.append(elemcount)

    # Add the nodes from "grainmesh" to "mesh"
    for node_id1, node1 in grainmesh.nodes.items():
        mesh.nodes[node2node[node_id1]] = node1

    # Add the elements from "grainmesh" to "mesh"
    mesh.element_sets["poly"+str(grainid)] = ElementSet("poly"+str(grainid), 3)
    for elem1 in grainmesh.elements.values():
        # Renumber vertices to new combined mesh;
        elem1.vertices = [node2node[v] for v in elem1.vertices]
        elemcount += 1
        mesh.elements[elemcount] = elem1
        mesh.element_sets["poly"+str(grainid)].ids.append(elemcount)
        elem2grain[elemcount] = grainid  # Need to have this map for keeping track of surfaces

    # Create element sets for all potential faces:
    for i in range(1, grainid):
        setname = "face"+ str(i) + "_" + str(grainid)
        if len(mesh.element_sets[setname].ids) == 0:
            del mesh.element_sets[setname]


def _find_duplicate_nodes(mesh, grainmesh):
    nodecount = 0
    if len(mesh.nodes) > 0:
        nodecount = max(mesh.nodes.keys())

    node_merge_list = dict()
    node2node = dict()
    for node_id1, node1 in grainmesh.nodes.items():
        found = False
        for node_id2, node2 in mesh.nodes.items():
            dist = numpy.linalg.norm([node1.x - node2.x, node1.y - node2.y, node1.z - node2.z])
            if dist < 1e-6:
                node_merge_list[node_id1] = node_id2
                found = True
                break
        if found:
            node2node[node_id1] = node_merge_list[node_id1]
        else:
            nodecount += 1
            node2node[node_id1] = nodecount
    return node2node, node_merge_list


def _read_nodes(f, mesh):
    f.readline() # Just read the number of nodes, except we don't need that since we use dictionaries
    while True:
        line = f.readline().strip()
        if line == "$EndNodes":
            return

        words = line.split()
        num = int(words[0])
        coord = list(map(float, words[1:]))
        node = Node(*coord)
        mesh.nodes[num] = node


def _read_elements(f, mesh):
    """
    Reads elements from the file.
    :param f: The file from where to read the elements from.
    :type f: file object at the elements
    :param mesh: Mesh to insert the read elements into.
    :type mesh: :class:`Mesh`
    :return: Nothing, but has the side effect of setting the pointer
             in the file object f to the line with the next keyword.
    """
    num = 0
    f.readline()  # Just read the number of elements, except we don't need that since we use dictionaries
    while True:
        line = f.readline().strip()
        if line == "$EndElements":
            return
        words = line.split()
        if len(words) < 9:
            continue
        num += 1
        #num = int(words[0])
        elem_nodes = list(map(int, words[-4:]))
        element = Element("C3D4", elem_nodes)
        mesh.elements[num] = element


class ReadMshFileError(Exception):
    """
    Base class for errors in the :mod:`read_from_neper_inp` module.
    """

    def __init__(self, status):
        """Creates an exception with a status."""
        Exception.__init__(self, status)
        self.status = status

    def __str__(self):
        """Return a string representation of the :exc:`ReadInpFileError()`."""
        return str(self.status)

